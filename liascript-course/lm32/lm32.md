# LM32

LatticeMico32 es un núcleo blando de microprocesador de 32 bits de Lattice Semiconductor optimizado para matrices de puertas programables en campo (FPGA). Utiliza una arquitectura Harvard, lo que significa que los buses de instrucciones y de datos están separados. La lógica de arbitraje del bus se puede utilizar para combinar los dos buses, si se desea.

La estructura de una máquina de estados algorítmica permite una mejor comprensión sobre la estructura de un procesador ya que integran los mismos componentes principales (unidad de control y camino de datos), la diferencia entre ellos es la posibilidad de programación y la configuración fija del camino de datos del procesador.

# Arquitectura del procesador LM32

La arquitectura del procesador MICO32 creado por la empresa Lattice semiconductor y gracias a que fué publicado bajo la licencia GNU, es posible su estudio, uso y modificación. La siguiente figura muestra por medio del diagrama de bloques la arquitectura del procesador LM32:

![Arquitectura LM32](img/arquitectura.png)

Este procesador en su arquitectura se compone de 6 etapas del *pipeline*, tambien cuenta con una logica de *bypass* que se encarga de hacer que el camino de datos entre operaciones sea más corto y se puedan ejecutar en un ciclo sencillo, de esta manera los datos no recorren todo el pipeline para completar instrucciones.

Las 6 etapas del pipeline son:

![Etapas pipeline](img/etapas_pipeline.png)

# Banco de registros

El LM32 posee 32 registros de 32 bits, el registro *r0* siempre contiene el valor 0, necesario para el correcto funcionamiento de los compiladores de C y ensamblador; los siguientes registros *r1 a r7* son utilizados para paso de argumentos y retorno de resultados en llamados a funciones; si una función requiere de más de 8 argumentos se hace necesario el uso de la pila *stack*. Los registros *r1 a r28* pueden ser utilizados como fuente o destino de cualquier instrucción. El registro *r29* es utilizado exclusivamente por la instrucción *call* para almacenar la dirección del retorno. El registro *r30 (ea)* es utilizado para almacenar el valor del contador del programa cuando se presenta una excepción. El registro *r31 (ba)* almacena el valor del contador de programa cuando se presenta una excepción tipo *breakpoint* o *watchpoint*. Los registros *r26 (gp)*, *r27 (fp)* y *r28 (sp)* son el punteero global, de frame y de pila respectivamente. Después del reset los 32 bits quedan indefinidos, por lo que es fundamental al inicializar el programa asegurar un 0 en el registro r0.

## Registro de estado y control

En la siguiente tabla, se pueden observar los registros de estado y control (CSR), indicando si son de lectura o escritura y el índice que se utiliza para tener aceeso al registro.

![Registro estado y control](img/registro_estado_control.png)

### Contador de programa (PC)

El contador de programa es un registro de 32 bits que contiene la direccion de la instruccion que se ejecuta actualmente. Debido a que todas las instrucciones son de 32 bits, los dos bits menos significativos de PC siempre son zero. El valor de este registro despuos del reset es h00000000.

### IE Habilitacion de interrupción

l registro IE contiene la bandera IE, que determina si se habilitan o no las interrupciones. Si este flag se desactiva, no se presentan interrupciones a pesar de la activacion individual realizada con IM. Existen dos bits BIE y EIE que se utilizan para almacenar el estado de IE cuando se presenta una excepcion tipo breakpoint u otro tipo de excepcion.

### EID Exception ID

El índice de la excepción es un número de 3 bits que indica la causa de la detención de la ejecución del programa. Las excepciones son eventos que ocurren al interior o al exterior del procesador y cambian el flujo normal de ejecución del programa. Los valores y eventos correspondientes son: 

0. Reset; se presenta cuando se activa la señal de reset del procesador.
1. Breakpoint; se presenta cuando se ejecuta la instrucción break o cuando se alcanza un punto de break hardware.
2. Instruction Bus Error; se presenta cuando falla la captura en una instrucción, regularmente cuando la dirección no es válida.
3. Watchpoint; se presenta cuando se activa un watchpoint.
4. Data Bus Error; se presenta cuando falla el acceso a datos, típica mente porque la dirección solicitada es inválida o porque el tipo de acceso no es permitido.
5. División por cero; Se presenta cuando se hace una división por cero.
6. Interrupción; se presenta cuando un periférico solicita atención por parte del procesador. Para que esta excepción se presente se deben habilitar las interrupciones globales (IE) y la interrupción del periférico (IM).
7. System Call; se presenta cuando se ejecuta la instrucción scall.

### IM Máscara de interrupción

La máscara de interrupción contiene un bit de habilitación para cada una de las 32 interrupciones, el bit 0 corresponde a la interrupción 0. Para que la interrupción se presente es necesario que el bit correspondiente a la interrupción y el flag IE sean igual a 1. Después del reset el valor de IM es h00000000.

### IP Interrupción pendiente

El registro IP contine un bit para cada una de las 32 interrupciones, este bit se activa cuando se presenta la interrupción asociada. Los bits del registro IP deben ser borrados escribiendo un 1 lógico.

## Set de instrucciones del procesador Mico32

Una instrucción no es más que una acción que mandamos a hacer en un procesador. Las instrucciones pueden ser operaciones aritméticas con diferentes tipos de datos como enteros, coma flotante, vectorial, escalar, operaciones lógicas, operaciones de movimientos de datos, operaciones de movimiento de bits (donde un bit es cambiado de posición), operaciones de salto, etc.

Para facilitar el estudio se realizó una división en cuatro grupos comenzando con las instrucciones aritméticas y lógicas, siguiendo con las relacio- nadas con saltos, después se analizará la comunicación con la memoria de datos y finalmente las relacionadas con interrupciones y excepciones. Para cada uno de estos grupos se mostrará el camino de datos (simplificado) asociado al conjunto de instrucciones.

### Instrucciones aritméticas

#### Entre registros

El camino de datos simplificado de las operaciones aritméticas y lógicas cuyos operandos son registros, y cuyo resultado se almacena en un registro. En otras palabras son de la forma: gpr[RX] = gpr[RY] OP gpr[RZ], donde: OP puede ser nor, xor, and, xnor, add, divu, modu, mul, or, sl, sr, sru, sub. Como puede verse en esta figura la instrucción contiene la información necesaria para direccionar los registros que almacenan los operandos RY (instruction d25:21) y RZ (instruction d 20:16), estas señales de 5 bits direccionan el banco de registros y el valor almacenado en ellos puede obtenerse en dos salidas diferentes ( gpr[rz] y gpr[ry]). En el archivo rtl/lm32/lm32 cpu.v se implementa el banco de registros de la siguiente forma:

**assign** reg data 0 = r e g i s t e r s [ read idx 0 d ];
**assign** reg data 1 = r e g i s t e r s [ read idx 1 d ];

En este código reg_data_0 y reg_data_1 son las dos salidas **gpr[rz]** y **gpr[ry]**; las señales *read_idx_0_d* y *read_idx_1_d* corresponden a *instruction_d 25:21* y *instruction_d 20:16* respectivamente. El contenido de los registros direccionados de esta forma son llevados al modulo *logic_op* donde se realiza la operacion correspondiente a la instrucción y el resultado pasa a través de los estados del pipeline hasta llegar a la señal *w_result* (parte inferior de la figura). Esta señnal entra al banco de
registros para ser almacenada en la dirección dada por la señal *write_idx_w* la cual es fijada por la instrucción, más espec´ ıficamente por (instruction_d 15:11). En el archivo *rtl/lm32/lm32_cpu.v* se implementa esta escritura al banco de registros de la siguiente forma:

'''
**always** @( **posedge** clk_i )

**begin**

    **if**( reg_write_enable_q_w == 'TRUE')
    
    registers[write_idx_w] <= w_result ;

**end**

'''

![Instrucciones entre registros](img/instrucciones_entre_registros.png)


#### Inmediatas

Existe otro grupo de operaciones lógicas y aritméticas en las que uno de los operandos es un registro y el otro es un número fijo, esto permite realizar operaciones con constantes que nos son almacenadas previamente en registros, sino que son almacenadas en la memoria de programa. En la figura se muestra como se modifica el camino de datos para este tipo de instrucciones; en ella, podemos observar que *instruction_d 25:21* direcciona uno de los operandos que está almacenado en el ban- co de registros y de forma similar al caso anterior el dato almacenado es llevado al bloque *logic_op*. El segundo operando es llevado a este bloque desde un multiplexor donde se hace una extensión de signo de *instruction_d 15:0* o se hace un corrimiento a la derecha de 16 posiciones; esto, para convertir el número de 16 bits a uno de 32 bits, lo que da como resultado *16instruction_d[15]*, *instruction_d[15:0]* y *instruction_d[15:0]*, *16’h0000* respectivamente; el corrimiento de 16 bits a la derecha se hace para poder realizar las operaciones andhi y orhi, las cuales solo operan sobre la parte alta de los operandos.

![Instrucciones inmediatas](img/instrucciones_inmediatas.png)

### Saltos

Los saltos permiten controlar el flujo de ejecución del programa posibilitando la implementación de ciclos, llamado a funciones, y toma de decisiones. En esta sub-sección estudiaremos el camino de datos resultante para este tipo de instrucciones. A diferencia de las instrucciones aritméticas y lógicas, en este tipo de instrucciones se modifica el valor del contador de programa.

#### Condicionales

En los saltos condicionales la instrucción se almacena la dirección de los registros que deben ser comparados, específicamente en *instruction_d 25:21* e *instruction_d 20:16*; los valores almacenados en estos registros son llevados al sumador y a un bloque especial que determina si se cumple o nó la condición (señales rojas en la gráfica); la señal *condition_met_x* se activa si la condición se cumple. En la figura se muestra el camino de datos para las instrucciones condicionales.

Para que el valor del contador de programa se modifique, es necesario que las señales *condition_met_x*, *branch_m* y *valid_m* se encuentren activas (señales anaranjadas en la gráfica); la señal *branch_m* se activa cuando la instrucción es de tipo *branch* o *call*; la señal *valid_m* se activa cuando se presenta una instrucción válida. Adicionalmente, es necesario que el procesador no se encuentre en un estado de *stall*. Si se cumplen las condiciones anteriores, se activará la señal *branch_taken_m*, la que le indicará a la unidad de instrucciones que cargue el valor de la señal *branch_target_m* en el contador de programa. 

El valor de branch_target_m (señal azul en la gráfica) es fijado por dos diferentes métodos: cuando se produce una excepción o cuando se produce un salto, la señal exception x selecciona el valor adecuado para cada caso. La señal branch_target_x es el resultado de la suma de pc_d y de branch_offset_d (para esta suma no se utiliza el bloque sumador). El valor de branch_offset es seleccionado por la señal select call immediate entre las señales call immediate (para instrucciones de llamado a función) y branch immediate; está última tiene como valor *16inst[15]*, *inst[15:0]*, lo que es una extensión de signo de la constante de 16 bits almacenado en la memoria de programa.

![Instrucciones saltos condicionales](img/instrucciones_saltos_condicionales.png)

En la figura se ilustran 3 ciclos que utilizan condicionales; en color azul se muestra el código en C y en negro se muestra el código implementado por el compilador. 

![Ejemplo saltos condicionales](img/ejemplo_saltos_condicionales.png)

#### Llamado a función y salto incondicional

Existen dos tipos de llamado a función y de salto incondicional; su diferencia radica en la forma de almacenar la dirección a la que deben saltar. En la figura ?? se muestra el camino de datos correspondiente a las instrucciones calli y bi, estas almacenan en la instrucción la dirección y en la figura ?? se muestra el camino de dato correspondiente a las instrucciones call y b las que almacenan la dirección en un registro.

Para ambos casos el contador de programa es modificado si se activan las señales condition met x, branch m y valid m; la se˜ nal valid m se activa cuando se presenta una instrucción válida; branch m (color amarillo en los graficos) se activa cuando la instrucción que se está ejecutando es un salto o un llamado a función; y condition met x se activa cuando se cumple con la condición para el salto, debido a que estos saltos y llamados son incondiconales, el MICO32 contempla dos casos en los que activa esta se˜ nal, tal como se muestra a continuación (tomado de rtl/lm32/lm32 cpu.v):

'''
**always** @∗
**begin**
  **case** ( instruction [28:26])
  3’b000 : condition met x = ‘TRUE;
  3’b110 condition met x = ‘TRUE;
  . . . .
  . . . .
  . . . .
  **default** : condition met x = 1’bx ;
  **endcase**
**end**
'''

Los bits instruction[28:26] hacen parte del código de la instrucción; el valor para las instrucciones bi y b es 000 y para call y callies 110,lo que activa condition met x cada vez que se presentan estas instrucciones.De forma similar a las instrucciones relacionadas con saltos condicionales el valor del contador de programa es igual al valor de las señal branch target x (señal de color verde en las figuras); el valor de esta señal para las instrucciones call y b proviene del valor almacenado en el registro seleccionado por instruction d [25:21]. Para las instrucciones calli y bi el valor está dado por la señal branch offset la que toma como valor 6ins[25],ins[25:0] o 16ins[15],ins[15:0] para una instrucción call o b respectivamente.

Adicionalmente, para las instrucciones de llamado a función call y calli se debe almacenar en el registro R29 la dirección de memoria siguiente a la que se realizó el llamado a la función, esto con el fín de retornar al flujo de programa principal, esto se logra haciendo uso del pipeline y se utiliza el valor del contador de programa pc m cuyo valor contiene el valor adecuado para el retorno del llamado a función; el valor de pc m (señal color morado en las figuras) es asignado a la señal w result del banco de registros para ser almacenado en el registro indicado por write idx (señal marrón en los gráficos); la que toma el valor de 29 cuando se presenta una
instrucción *calli* o *call*.

![Saltos y funciones](img/saltos_y_funciones.png)

![Saltos y funciones inmediatos](img/saltos_y_funciones_inmediatos.png)
 
En la figura se muestra un ejemplo de uso de la función call. El código en C utilizado para este ejemplo se muestra en color azul. La línea de código result1 = function(0x30) hace el llamado a la función function pasándole el parámetro 0x30 (decimal 48); el código implementado por el compilador se muestra junto al código en C; como se mencionó  anteriormente, los primeros registros del banco de registros se usan para pasar parámetros entre funciones, en el paso 1, se almacena el valor 0x30 (48 decimal) en r1; en el paso dos se hace un llamado inmediato a función a la dirección de memoria 0x8C, lo que hace que el valor del contador de programa tome el valor 0x8C y se almacene el valor 0x310 en el registro ra.

La función function está declarada como int function(int x) y reside en la posición de memoria 0x8C. En el paso 3, se almacena el valor de los registros que se utilizan en la función con el fín de restaurarlos antes de retornar al programa donde fué llamada, esto se hace debido a que solo existe un banco de registros en el procesador y si no se hace esto el valor de los registros antes y después del llamado será diferente lo que ocasionará errores en los algoritmos implementados. EL registro ra almacena el valor de la dirección de retorno, y se almacena para asegurar que cuando se hagan llamados a función anidados se retorne a la dirección adecuada. En el paso 4 se restaura el valor de los registros, garantizando la continuidad del programa principal; finalmente, en el paso 6 la función ret carga el valor del ra en el contador de programa.

![Ejemplo llamado a función](img/ejemplo_llamado_funcion.png)

En la figura se ilustra la importancia del almacenamiento de los registros en los llamados a funciones, para este ejemplo se consideró el registro ra; cuando se almacena el registro ra en la función F2 para ser restaurado al finalizar la función el flujo de programa retorna a la función F1, lo que se ejecuta correctamente en los dos casos. Cuando finaliza F1 el valor de ra varía; cuando no se almacena el valor la dirección de retorno de F1 es modificada por lo que cuando se retorna el contador de programa se hace igual a la dirección de retorno de F2.

![Llamado a función anidado](img/llamado_funcion_anidado.png)

### Comunicación con la memoria de datos

Antes de estudiar el camino de datos correspondiente a este grupo de instrucciones, hablaremos de los tipos de datos que soporta el procesador MICO32. En la figura se muestran ejemplos de manipulación de diferentes tipos de datos y como estos son tratados en la memoria del procesador.

#### Tipos de datos

El primer tipo de datos que se muestra en esta figura es el char, la variable data8 es declarada como un volatile unsigned char *, es decir un puntero a un char sin signo tipo volatile; los tipos de datos volatile le indican al compilador que no realice optimizaciones sobre esta variable, lo que es importante cuando se direccionan periféricos. Al puntero data8 se le asigna la dirección 0x400 y el valor 0x44. Si se aumenta el valor de la dirección del puntero en una posición data8++ la nueva dirección será 0x401 y si se aumenta de nuevi pasará a ser 0x402; lo que indica que el procesador a pesar de ser de 32 bits puede realizar direccionamiento con granularidad byte; esto es muy conveniente para un almacenamiento eficiente de información, de no ser as´ ı se utilizar´ ıa una palabra de 32 bits para almacenar 8 bits.

La segunda parte de la figura se ilustra el manejo del tipo de dato short el cual es de 16 bits; para esto se utiliza en puntero data16 con una dirección inicial de 0x200 y un valor de 0x2020; al aumentar la dirección del puntero en 1 (data16++) la dirección resultante es 0x202, lo que permite el almacenamiento eficiente de este
tipo de dato.

Finalmente se ilustra el tipo de datos int y se observa como las direcciones de memoria inical y final después de aumentar el valor del puntero son 0x300 0x304; lo que muestra que el direccionamiento interno de la memoria depende del tipo de datos.

![Tipos de datos soportados procesador MICO32](img/tipos_datos_soportados.png)

El procesador MICO32 posee 4 señales D SEL O[3:0] que son utilizadas para indicarle a los periféricos el tipo de operación de lectura/escritura que se está efectuando; en la figura se observa que estas señales se activan de forma individual indicando el byte que se está direccionando; en la figura las señales se activan por parejas indicando el grupo de 2 bytes que se está direccionando; finalmente en la figura las 4 se˜ nales se activan al tiempo lo que indica un acceso a los 4 bytes al mismo tiempo.

![Acceso datos tipo char](img/acceso_dato_char.png)

![Acceso datos tipo short](img/acceso_dato_short.png)

![Acceso datos tipo int](img/acceso_dato_int.png)

#### Escritura a la memoria de datos

El acceso a memoria de datos permite extender las capacidades del procesador posibilitando la conexión de periféricos; los que a su vez, realizan la comunicación con el exterior utilizando diferentes protocolos de comunicación y medios físicos. En esta subsección se describirá la forma en la que el MICO32 implementa las operaciones de lectura y escritura a la memoria de datos.

En la figura se ilustra el camino de datos asociado a las instrucciones sb, sh y sw. En las tres, el valor contenido en el registro direccionado por instruction d[25:21] (RX señales color rojo en la figura) más el valor de 16 bits (con signo extendido a 32 bits) forman la dirección a la que se desea escribir. El valor contenido en el registro direccionado por instruction d[20:16] (RY se˜ nales color azul en la figura) corresponde al dato que será escrito en esa posición de memoria; de esta forma se construyen los buses de datos y direcciones del procesador. Cómo se dijo anteriormente el MICO32 direcciona con granularidad de byte, por esta razón en las instrucciones sh y sw se indica el valor escrito en las direcciones +1 y +1, +2 y +3 respectivamente; indicando el tama˜ no en bytes del tipo de dato escrito. Estas señales ingresan a un módulo llamado load store unit que se encarga de generar las señales correspondientes al bus wishbone, más adelante estudiaremos en detalle el funcionamiento de este bus.

En la figura ??, y ?? se muestran las formas de onda cuando se escribe un dato tipo char (0x44) a la dirección 0x400, el dato escrito en el bus es 0x44444444 para que el periférico pueda utilizar cualquiera de las cuatro partes del bus de datos D DAT O[7:0], D DAT O[15:8], D DAT O[23:16], D DAT O[31:24], algo similar ocurre en la escritura del tipo de dato short (con valor 0x2020) mostrado en la figura ??, aquí se repite el dato para poder utilizar dos partes del bus del datos D DAT O[15:0] y D DAT O[31:16].

#### Lectura

En la figura ?? se muestra el camino de datos asociado a las instrucciones lb/lbu, lh/lhu y lw. La dirección de la cual se leera se calcula de forma similar al caso de la escritura; el valor contenido en el registro direccionado por instruction d[25:21] (RY se˜ nales color rojo en la figura). El dato le´ ıdo por el módulo load store unit (señal morada en la figura) es almacenado en el registro cuya dirección está dada por instruction d[20:16].

### Interrupciones

Existen dos formas de conocer si un periférico conectado al procesador requiere atención por parte del procesador; examinando de forma constante los registros de estado del periférico o utilizando interrupciones. La consulta constante de los registros de estado del periférico requiere incluir en el código una rutina que realice esta operación, la cual debe ser llamada de forma regular en el programa principal, la velocidad con que se realice esta consulta debe ser la adecuada para que no se pierdan eventos; debido a esto; uno de los problemas de esta técnica es que al aumentar el número de periféricos aumenta el tiempo entre consultas para un periférico, lo que aumenta la posibilidad de pérdida de eventos; adicionalmente, aumenta el tiempo dedicado a la consulta, lo que disminuye el tiempo disponible para ejecutar las tareas software en el procesador.

Las interrupciones modifican el flujo normal de ejecución del sistema y son originadas por señales dedicadas, lo que hace que su atención ocurra de forma inmediata. Cuando se presenta una interrupción, el valor del contador de programa toma un valor fijo que recibe el nombre de vector de interrupción, el valor del vector de interrupción está formado por (ver figura ?? señales de color rojo) una dirección base EBA (Exception Base Address) que por defecto es 0x00, un índice que indica la exepción que se presentó eid x (6 para la interrupción) y tres ceros; estos tres ceros hacen que el espacio entre vectores de excepción sea de 8 palabras de 32 bits, por lo que la rutina de atención a la interrupción debe tener máximo 8 instrucciones (esta rutina se explicará más adelante); para la interrupción el valor del vector es de 0x30. 

Como se puede observar en la figura ?? para que se genere una excepción (señales de color azul), se debe activar cualquiera de las señales instruction bus error exception, system call exception exception,data bus error exception,divide by zero exception o interrupt exception; lo que activará la se˜ nal branch taken m quien a su vez realiza el cambio en el contador de programa pc a. Para que la se˜ nal interrupt exception se active es necesario: 1- habilitar la generación de interrupciones, es decir, que el flag ie (interrupt enable) está activo; 2- habilitar la generación de la interrupción deseada, para esto el bit correspondiente a la interrupción debe ser igual a 1 en la señal im (interrupt mask), lo que recibe el nombre de enmascaramiento y 3 - Que el periférico asociado a la interrupción realice una solicitud de atención activando su señal de interrupción, lo que origina una activación de la se˜ nal correspondiente en ip (interrupt pending).
 
Al activarse la señal exception x la variable que direcciona el registro a ser escrito en el banco de registros write idx toma el valor 30 decimal (ea - exception address) y el valor a ser escrito (w result) será pc m, 2’b00 (los saltos en el contador de programa es de a 4 bytes, debido a que las instrucciones son de 32 bits, por esta razón los dos bits menos significativos no son tomados en cuenta); lo que garantiza que al salir de la interrupción, el programa principal continuará donde se interrumpió.

![Generación de excepciones](img/generacion_de_excepciones.png)

#### Rutina de atención a la interrupción

A continuación se lista la rutina que se ejecuta cada vez que se presenta una interrupción; como se dijo anteriormente, la dirección del vector de interrupción debe ser 0x48, por lo que este código debe residir en la memoria de programa en dicha dirección.

8     sw       (sp +0) , ra
49    calli    _save_all
50    rcsr     r1 , IP
51    calli    irq_handler
52    mvhi     r1 , 0 xffff
53    ori      r1 , r1 , 0 xffff
54    wcsr     IP , r1
55    bi       _restore_all_anderet

En la línea 48 se almacena el valor del registro ra en la pila (la pila es una región de la memoria RAM que se utiliza para diferentes propósitos en la ejecución de un programa), esto se hace para que al salir de la rutina de atención a la interrupción el programa continúe de forma adecuada, de no hacer esto, si la interrupción se produjo cuando se estaba ejecutando una función el valor de retorno de la interrupción se modificaría. 

En la línea 49 se hace un llamado a la función save all:

      addi sp , sp , −128
      sw ( sp +4) , r1
      . . .
      sw ( sp +108) , r27
#endif
      sw ( sp +120) , ea
      sw ( sp +124) , ba
      /∗ ra and sp need special handling , as they have been modified ∗/
      lw r1 , ( sp +128)
      sw ( sp +116) , r1
      mv r1 , sp
      addi r1 , r1 , 128
      sw ( sp +112) , r1
      ret

En esta función, toma una “fotografía” del estado del procesador en el instante en que se presenta la interrupción, almacenando el valor de todos los registros en la pila, esto se hace para garantizar que el estado del procesador antes y después de la interrupción sea el mismo. En la línea 49 se almacena el valor de la señal ip (interrupt pending) en el registro r1, esto se hace para pasar parámetros a la función que será llamada en la línea 50. irq handler es la función que realizará las acciones correspondientes a una determinada interrupción, esta función debe ser declarada en C en cualquier archivo que haga parte del código fuente de la aplicación (en los ejemplos del repositorio se
declara en el archivo soc-hw.c) como: void irq handler(uint32 t pending).

En las líneas 51 - 53 se llena con unos la señal IP, lo que equivale a una restauración de esta señal, y puede verse como una forma de informarle al procesador que las interrupciones ya fueron atendidas. Finalmente en la línea 54 se hace un llamado a la función restore all and eret:

      lw r1 , ( sp +4)
      . . .
      lw r27 , ( sp +108)
      lw ra , ( sp +116)
      lw ea , ( sp +120)
      lw ba , ( sp +124)
      /∗ Stack pointer must be restored last , in case i t has been updated ∗/
      lw sp , ( sp +112)
      eret

Esta función: restaura el valor de todos los registros del procesador, incluyendo los registros ra, ea y ba, el registro ea se almacena para asegurar el correcto funcionamiento ante el caso de excepciones anidades; y ejecuta la instrucción eret la que hace que el contador de programa tome el valor almacenado en el registro ea con lo que el programa retorna a la siguiente instrucción del punto donde se generó la interrupción.

Como se mencionó anteriormente, para que la interrupción se presente es necesario habilitar las interrupciones globales y la máscara asociada al periférico. Para esto, el archivo crt0ram.S suministra las siguientes funciones:

irq enable :
      mvi r1 , 1
      wcsr IE , r1
      ret
irq disable :
      mvi r1 , 0
      wcsr IE , r1
      ret
irq set mask :
      wcsr IM, r1
      ret

En este código se utiliza la instrucción wcsr y en la función de atención a la interrupción ya se había utilizado la instrucción rcsr (rcsrr1,IP); estas instrucciones realizan operaciones de escritura y lectura sobre los registros de estatus y control del procesador. En la figura ?? se muestra el camino de datos relacionado con estas intrucciones.

El camino de color rojo muestra la escritura utilizando la instrucción wcsr; instruction d[20:16] contiene la dirección del registro a ser escrito en csr; y instruction d[25:21] el registro de estatus y control a escribir.

La lectura de los registros de estado y control se muestra en color morado en la figura; de forma similar a la escritura instruction d[25:21] direcciona el registro a leer y instruction d[15:11] la dirección del registro que almacenará el valor leído.

### Retorno de función y de excepción

La figura ?? muestra el camino de datos asociado a las instrucciones de retorno de excepción y de función eret y ret; en estas instrucciones, el valor de la dirección del registro que va a ser almacenado en el contador de programa es fijo (instruction d[25:21]), siendo 30 para la instrucción eret y 29 para la instrucción ret. El valor contenido en estos registros pasa a la se˜ nal branch target y su valor será almacenado en el contador de programa retornando a la dirección siguiente a la que se produjo la excepción o el llamado a función.

![Datos de retorno función y excepción](img/datos_retorno_funcion_y_excepcion.png)

En la Figura ?? se resume el proceso de atención a la interrupción. La solicitud de atención por parte de un periférico recibe el nombre de IRQ (interrupt request) y la rutina que atiende esta solicitud recibe el nombre de ISR (interrupt service routine).

![Flujo atención de interrupción](img/flujo_atencion_de_interrupcion.png)

## Arquitectura del SoC LM32

En la sección anterior se explicó el funcionamiento detallado de cada grupo de instrucciones del procesador MICO32; en esta sección se realizará una descripción de un SoC (sistema sobre silicio) basado en el procesador MICO32; esta arquitectura permitirá entender los SoC modernos desde el punto de vista estructural y de programación

En la figura ?? se muestra el diagrama de bloques del SoC LM32, el cual tiene como unidad de procesamiento central el procesador MICO32; esta CPU se conecta a una serie de periféricos a través de el bus wishbone. La funcionalidad del SoC está determinada por los periféricos implementados, en esta sección se realizará una descripción de cuatro periféricos básicos para el desarrollo de operaciones básicas de entrada/salida:

![Diagrama de bloques LM32](img/diagrama_bloques_lm32.png)

* Boot-RAM: Esta memoria almacena la aplicación que se ejecutará al inicializar el SoC.
* UART (Universal Asynchronous Receiver-Transmitter): Puerto serie que permite comunicarse con el exterior y es utilizado como medio de depuración.
* TIMER: Encargado de generar bases de tiempo precisas, de vital importancia en el funcionamiento de la mayor´ ıa de las aplicaciones.
* GPIO: Pines de entrada/salida de propósito general.

Adicionalmente, existe un módulo llamado conbus que realiza la interconexión entre los periféricos y el procesador, su arquitectura y funcionamiento se explicarán más adelante.

### Bus wishbone

El bus wishbone es un bus diseñado para comunicar los diferentes comonentes de un SoC, este bus es abierto y puede ser utilizado libremente. A continueación se listan las señales que componen este bus:

