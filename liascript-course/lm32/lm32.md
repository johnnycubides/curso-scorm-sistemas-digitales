# LM32

LatticeMico32 es un núcleo blando de microprocesador de 32 bits de Lattice Semiconductor optimizado para matrices de puertas programables en campo (FPGA). Utiliza una arquitectura Harvard, lo que significa que los buses de instrucciones y de datos están separados. La lógica de arbitraje del bus se puede utilizar para combinar los dos buses, si se desea.

La estructura de una máquina de estados algorítmica permite una mejor comprensión sobre la estructura de un procesador ya que integran los mismos componentes principales (unidad de control y camino de datos), la diferencia entre ellos es la posibilidad de programación y la configuración fija del camino de datos del procesador.

# Arquitectura del procesador LM32

La arquitectura del procesador MICO32 creado por la empresa Lattice semiconductor y gracias a que fué publicado bajo la licencia GNU, es posible su estudio, uso y modificación. La siguiente figura muestra por medio del diagrama de bloques la arquitectura del procesador LM32:

![Arquitectura LM32](img/arquitectura.png)

Este procesador en su arquitectura se compone de 6 etapas del *pipeline*, tambien cuenta con una logica de *bypass* que se encarga de hacer que el camino de datos entre operaciones sea más corto y se puedan ejecutar en un ciclo sencillo, de esta manera los datos no recorren todo el pipeline para completar instrucciones.

Las 6 etapas del pipeline son:

![Etapas pipeline](img/etapas_pipeline.png)

# Banco de registros

El LM32 posee 32 registros de 32 bits, el registro *r0* siempre contiene el valor 0, necesario para el correcto funcionamiento de los compiladores de C y ensamblador; los siguientes registros *r1 a r7* son utilizados para paso de argumentos y retorno de resultados en llamados a funciones; si una función requiere de más de 8 argumentos se hace necesario el uso de la pila *stack*. Los registros *r1 a r28* pueden ser utilizados como fuente o destino de cualquier instrucción. El registro *r29* es utilizado exclusivamente por la instrucción *call* para almacenar la dirección del retorno. El registro *r30 (ea)* es utilizado para almacenar el valor del contador del programa cuando se presenta una excepción. El registro *r31 (ba)* almacena el valor del contador de programa cuando se presenta una excepción tipo *breakpoint* o *watchpoint*. Los registros *r26 (gp)*, *r27 (fp)* y *r28 (sp)* son el punteero global, de frame y de pila respectivamente. Después del reset los 32 bits quedan indefinidos, por lo que es fundamental al inicializar el programa asegurar un 0 en el registro r0.

## Registro de estado y control

En la siguiente tabla, se pueden observar los registros de estado y control (CSR), indicando si son de lectura o escritura y el índice que se utiliza para tener aceeso al registro.

![Registro estado y control](img/registro_estado_control.png)

### Contador de programa (PC)

El contador de programa es un registro de 32 bits que contiene la direccion de la instruccion que se ejecuta actualmente. Debido a que todas las instrucciones son de 32 bits, los dos bits menos significativos de PC siempre son zero. El valor de este registro despuos del reset es h00000000.

### IE Habilitacion de interrupción

l registro IE contiene la bandera IE, que determina si se habilitan o no las interrupciones. Si este flag se desactiva, no se presentan interrupciones a pesar de la activacion individual realizada con IM. Existen dos bits BIE y EIE que se utilizan para almacenar el estado de IE cuando se presenta una excepcion tipo breakpoint u otro tipo de excepcion.

### EID Exception ID

El índice de la excepción es un número de 3 bits que indica la causa de la detención de la ejecución del programa. Las excepciones son eventos que ocurren al interior o al exterior del procesador y cambian el flujo normal de ejecución del programa. Los valores y eventos correspondientes son: 

0. Reset; se presenta cuando se activa la señal de reset del procesador.
1. Breakpoint; se presenta cuando se ejecuta la instrucción break o cuando se alcanza un punto de break hardware.
2. Instruction Bus Error; se presenta cuando falla la captura en una instrucción, regularmente cuando la dirección no es válida.
3. Watchpoint; se presenta cuando se activa un watchpoint.
4. Data Bus Error; se presenta cuando falla el acceso a datos, típica mente porque la dirección solicitada es inválida o porque el tipo de acceso no es permitido.
5. División por cero; Se presenta cuando se hace una división por cero.
6. Interrupción; se presenta cuando un periférico solicita atención por parte del procesador. Para que esta excepción se presente se deben habilitar las interrupciones globales (IE) y la interrupción del periférico (IM).
7. System Call; se presenta cuando se ejecuta la instrucción scall.

### IM Máscara de interrupción

La máscara de interrupción contiene un bit de habilitación para cada una de las 32 interrupciones, el bit 0 corresponde a la interrupción 0. Para que la interrupción se presente es necesario que el bit correspondiente a la interrupción y el flag IE sean igual a 1. Después del reset el valor de IM es h00000000.

### IP Interrupción pendiente

El registro IP contine un bit para cada una de las 32 interrupciones, este bit se activa cuando se presenta la interrupción asociada. Los bits del registro IP deben ser borrados escribiendo un 1 lógico.

## Set de instrucciones del procesador Mico32

Una instrucción no es más que una acción que mandamos a hacer en un procesador. Las instrucciones pueden ser operaciones aritméticas con diferentes tipos de datos como enteros, coma flotante, vectorial, escalar, operaciones lógicas, operaciones de movimientos de datos, operaciones de movimiento de bits (donde un bit es cambiado de posición), operaciones de salto, etc.

Para facilitar el estudio se realizó una división en cuatro grupos comenzando con las instrucciones aritméticas y lógicas, siguiendo con las relacio- nadas con saltos, después se analizará la comunicación con la memoria de datos y finalmente las relacionadas con interrupciones y excepciones. Para cada uno de estos grupos se mostrará el camino de datos (simplificado) asociado al conjunto de instrucciones.

### Instrucciones aritméticas

#### Entre registros

El camino de datos simplificado de las operaciones aritméticas y lógicas cuyos operandos son registros, y cuyo resultado se almacena en un registro. En otras palabras son de la forma: gpr[RX] = gpr[RY] OP gpr[RZ], donde: OP puede ser nor, xor, and, xnor, add, divu, modu, mul, or, sl, sr, sru, sub. Como puede verse en esta figura la instrucción contiene la información necesaria para direccionar los registros que almacenan los operandos RY (instruction d25:21) y RZ (instruction d 20:16), estas señales de 5 bits direccionan el banco de registros y el valor almacenado en ellos puede obtenerse en dos salidas diferentes ( gpr[rz] y gpr[ry]). En el archivo rtl/lm32/lm32 cpu.v se implementa el banco de registros de la siguiente forma:

**assign** reg data 0 = r e g i s t e r s [ read idx 0 d ];
**assign** reg data 1 = r e g i s t e r s [ read idx 1 d ];

En este código reg_data_0 y reg_data_1 son las dos salidas **gpr[rz]** y **gpr[ry]**; las señales *read_idx_0_d* y *read_idx_1_d* corresponden a *instruction_d 25:21* y *instruction_d 20:16* respectivamente. El contenido de los registros direccionados de esta forma son llevados al modulo *logic_op* donde se realiza la operacion correspondiente a la instrucción y el resultado pasa a través de los estados del pipeline hasta llegar a la señal *w_result* (parte inferior de la figura). Esta señnal entra al banco de
registros para ser almacenada en la dirección dada por la señal *write_idx_w* la cual es fijada por la instrucción, más espec´ ıficamente por (instruction_d 15:11). En el archivo *rtl/lm32/lm32_cpu.v* se implementa esta escritura al banco de registros de la siguiente forma:

**always** @( **posedge** clk_i )
**begin**
  **if**( reg_write_enable_q_w == 'TRUE')
    registers[write_idx_w] <= w_result ;
**end**

![Instrucciones entre registros](img/instrucciones_entre_registros.png)

#### Inmediatas

Existe otro grupo de operaciones lógicas y aritméticas en las que uno de los operandos es un registro y el otro es un número fijo, esto permite realizar operaciones con constantes que nos son almacenadas previamente en registros, sino que son almacenadas en la memoria de programa. En la figura se muestra como se modifica el camino de datos para este tipo de instrucciones; en ella, podemos observar que *instruction_d 25:21* direcciona uno de los operandos que está almacenado en el ban- co de registros y de forma similar al caso anterior el dato almacenado es llevado al bloque *logic_op*. El segundo operando es llevado a este bloque desde un multiplexor donde se hace una extensión de signo de *instruction_d 15:0* o se hace un corrimiento a la derecha de 16 posiciones; esto, para convertir el número de 16 bits a uno de 32 bits, lo que da como resultado *16instruction_d[15]*, *instruction_d[15:0]* y *instruction_d[15:0]*, *16’h0000* respectivamente; el corrimiento de 16 bits a la derecha se hace para poder realizar las operaciones andhi y orhi, las cuales solo operan sobre la parte alta de los operandos.

![Instrucciones inmediatas](img/instrucciones_inmediatas.png)

### Saltos

Los saltos permiten controlar el flujo de ejecución del programa posibilitando la implementación de ciclos, llamado a funciones, y toma de decisiones. En esta sub-sección estudiaremos el camino de datos resultante para este tipo de instrucciones. A diferencia de las instrucciones aritméticas y lógicas, en este tipo de instrucciones se modifica el valor del contador de programa.

#### Condicionales

En los saltos condicionales la instrucción se almacena la dirección de los registros que deben ser comparados, específicamente en *instruction_d 25:21* e *instruction_d 20:16*; los valores almacenados en estos registros son llevados al sumador y a un bloque especial que determina si se cumple o nó la condición (señales rojas en la gráfica); la señal *condition_met_x* se activa si la condición se cumple. En la figura se muestra el camino de datos para las instrucciones condicionales.

Para que el valor del contador de programa se modifique, es necesario que las señales *condition_met_x*, *branch_m* y *valid_m* se encuentren activas (señales anaranjadas en la gráfica); la señal *branch_m* se activa cuando la instrucción es de tipo *branch* o *call*; la señal *valid_m* se activa cuando se presenta una instrucción válida. Adicionalmente, es necesario que el procesador no se encuentre en un estado de *stall*. Si se cumplen las condiciones anteriores, se activará la señal *branch_taken_m*, la que le indicará a la unidad de instrucciones que cargue el valor de la señal *branch_target_m* en el contador de programa. 

El valor de branch_target_m (señal azul en la gráfica) es fijado por dos diferentes métodos: cuando se produce una excepción o cuando se produce un salto, la señal exception x selecciona el valor adecuado para cada caso. La señal branch_target_x es el resultado de la suma de pc_d y de branch_offset_d (para esta suma no se utiliza el bloque sumador). El valor de branch_offset es seleccionado por la señal select call immediate entre las señales call immediate (para instrucciones de llamado a función) y branch immediate; está última tiene como valor *16inst[15]*, *inst[15:0]*, lo que es una extensión de signo de la constante de 16 bits almacenado en la memoria de programa.

![Instrucciones saltos condicionales](img/instrucciones_saltos_condicionales.png)

En la figura se ilustran 3 ciclos que utilizan condicionales; en color azul se muestra el código en C y en negro se muestra el código implementado por el compilador. 

![Ejemplo saltos condicionales](img/ejemplo_saltos_condicionales.png)

#### Llamado a función y salto incondicional

Existen dos tipos de llamado a función y de salto incondicional; su diferencia radica en la forma de almacenar la dirección a la que deben saltar. En la figura ?? se muestra el camino de datos correspondiente a las instrucciones calli y bi, estas almacenan en la instrucción la dirección y en la figura ?? se muestra el camino de dato correspondiente a las instrucciones call y b las que almacenan la dirección en un registro.

Para ambos casos el contador de programa es modificado si se activan las señales condition met x, branch m y valid m; la se˜ nal valid m se activa cuando se presenta una instrucción válida; branch m (color amarillo en los graficos) se activa cuando la instrucción que se está ejecutando es un salto o un llamado a función; y condition met x se activa cuando se cumple con la condición para el salto, debido a que estos saltos y llamados son incondiconales, el MICO32 contempla dos casos en los que activa esta se˜ nal, tal como se muestra a continuación (tomado de rtl/lm32/lm32 cpu.v):

'''
**always** @∗
**begin**
  **case** ( instruction [28:26])
  3’b000 : condition met x = ‘TRUE;
  3’b110 condition met x = ‘TRUE;
  . . . .
  . . . .
  . . . .
  **default** : condition met x = 1’bx ;
  **endcase**
**end**
'''
